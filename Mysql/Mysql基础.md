# Mysql 基础

## 1. 基础架构
### 1.1 架构图
![](https://img-1253127117.cos.ap-guangzhou.myqcloud.com/20210629201712.png)

### 1.2 缓存
除非是静态表，大多数情况下不建议使用缓存，因为经常更新的数据，缓存命中非常低
## 2.Mysql 执行流程
![](https://img-1253127117.cos.ap-guangzhou.myqcloud.com/20210629200808.png)

## 3. sql是如何执行的
### 3.1 redolog 和 binlog
redo log: innoDb引擎写入内存的日志
![](https://img-1253127117.cos.ap-guangzhou.myqcloud.com/20210629202228.png)

## 4. 事务隔离
### 4.1事务的基本性质
ACID:原子性，一致性，隔离性，持久性

### 4.2事务隔离级别
 - 读未提交：一个事务未提交时，它做的变更就能被别的事务看到
 - 读提交：一个事务提交之后，它做的变更才会被其他事务看到
 - 可重复读：事务执行过程中和事务开始的数据一致，未提交的数据对其他事务也不可见
 - 串行化：对于同一行记录，读会加读锁，写会家写锁，当出现读写锁冲突，后访问的事务必须等前一个事务执行完成，才能继续执行

 -  在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。*

查看隔离级别 `show variables like 'transaction_isolation';` 

### 4.3事务的启动方式
- 显示启动：begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。
- set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。

查询长事务
```sql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

## 5索引
### 5.1索引的常见模型
- hash表
特点：key 可能重复，无序，插入快，查询慢（因为是无序的，所以需要重头到位查询）
适用场景：等值查询，不适合范围查询
- 有序数组
特点：查询快，但是插入慢（因为是有序的，当向中间插入一条数据，后面的数据的索引需要重建）
适用场景：静态存储（不怎么变动的数据）
- 二叉树（N叉树）


